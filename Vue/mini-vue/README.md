# reacitve
reactive 只能将应用类型代理成响应式 是因为proxy只接受引用类型

被代理对象中的任意属性发生修改都应该将用到了这个属性的各个函数重新执行一遍。那么在此之前，需要知道哪些属性被用到了，也就是依赖收集。

1. 用proxy代理了对象
2. 在代理函数 get中 对使用了的属性做 副作用函数收集
3. 在代理函数 set中 对修改了的属性做 副作用函数的触发


# Reflect
将ES6及之后的所有 隶属于 Object 对象上的方法，挪到的 Reflect 对象上 (Reflect主要解决了一些程序报错问题)

配合 Proxy 使用

# 用ref还是reactive?
这个取决于自己，没有谁好谁差
ref缺点就是写法上比reactive多了一个.value
所以当一个组件里面响应式变量 多的时候 用reactive 不多的时候 用ref 减轻代码量

# 总结
reactive 使用proxy代理了对象的各种操作行为，当属性被读取值、设置值、判断值这些行为当中，为属性添加副作用函数，在属性被修改值或者删除值的时候，去触发这些属性身上绑定的副作用函数，来实现响应效果。

ref 身上当参数是对象的时候，依然是借助reactive代理对象实现响应式的；当参数式原始值的时候，给原始值添加value函数并采用了原生JS内置的setter和getter效果来实现为属性添加副作用函数和触发函数进而达到响应式效果的。

